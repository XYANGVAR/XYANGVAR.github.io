<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[铺地毯]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%2F</url>
    <content type="text"><![CDATA[题目描述: 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出格式输入格式：输入共n+2行 第一行，一个整数n，表示总共有n张地毯 接下来的nn行中，第 i+1行表示编号ii的地毯的信息，包含四个正整数a ,b ,g ,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标(a,b)以及地毯在x轴和y轴方向的长度 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标(x,y)输出格式：输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 解答：简单进行一下模拟，不断更新最上面的地毯。12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct sq&#123; ll a; ll b; ll g; ll k;&#125;sq[10001];int main()&#123; ll n,x,y; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;sq[i].a&gt;&gt;sq[i].b&gt;&gt;sq[i].g&gt;&gt;sq[i].k; &#125; cin&gt;&gt;x&gt;&gt;y; int ans=-1; for(int i=0;i&lt;n;i++) &#123; if((x&gt;=sq[i].a)&amp;&amp;(x&lt;=(sq[i].a+sq[i].g))&amp;&amp;(y&gt;=sq[i].b)&amp;&amp;(y&lt;=sq[i].b+sq[i].k)) ans=i+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制奇偶位快速转换]]></title>
    <url>%2F2019%2F04%2F06%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E5%81%B6%E4%BD%8D%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[将整数二进制的奇偶位快速互换 有的题目需要将一个整数的二进制的奇偶位做互换，这时需要用到位运算的异或算符^。具体原理如下： 9的二进制1001，互换之后为0110。为了这个互换，我们需要将1001分别与上1010和0101记做ou（偶数位保留）和ji(奇数位保留)，将ou右移一位；将ji左移一位之后两者做异或运算即可。 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int m(int i)&#123;int ou=i&amp;0xaaaaaaaa;//这里0xaaaaaaaa作为1010 1010...取出偶数位共32位int ji=i&amp;0x55555555;//这里0x55555555作为0101 0101...取出奇数位共32位return (ou&gt;&gt;1)^(ji&lt;&lt;1);&#125;int main()&#123; int a=9; int b=m(a); cout&lt;&lt;b&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字转字符串itos]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%95%B0%E5%AD%97%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2itos%2F</url>
    <content type="text"><![CDATA[把一个数字转为字符串s 在输入的过程中经常需要将一个数字转化为字符串方便处理这里引入一个将数字转为字符串的函数i2s，主要利用c++的输入流。 代码：12345678910111213141516171819#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;using namespace std;void i2s(int num,string &amp;str)&#123; stringstream ss; ss&lt;&lt;num; ss&gt;&gt;str;&#125;int main()&#123; int i; cin&gt;&gt;i; string s; i2s(i,s); cout&lt;&lt;s&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度plus]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%AB%98%E7%B2%BE%E5%BA%A6plus%2F</url>
    <content type="text"><![CDATA[高精度大数的加法 众所周知，c++中最大整型的long long 一般表示8位，如果计算的数字超过这个范围的话会产生溢出的情况，这时需要用字符串人工来表述一个整数加法过程，所谓的高精度加法。 首先我们定义两个string类型的字符串作为我们输入的加数，（输入的时候可以利用itos函数将数字转为串）接着定义一个答案串长度为len，为了方便计算，我们先将字符串反转接着将第一个数存入答案串中，定义进位为tmp，然后用循环将另一个加数逐位加到答案串中，并计算进位情况。 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#include&lt;sstream&gt;using namespace std;string add(string a,string b)&#123; a=a.substr(a.find_first_not_of('0')); b=b.substr(b.find_first_not_of('0')); long long lenA=a.length(); long long lenB=b.length(); long long len=max(lenA,lenB)+10; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans(len,'0'); for(int i=0;i&lt;lenA;i++) &#123; ans[i]=a[i]; &#125; int tmp=0; for(int i=0;i&lt;len;i++) &#123; if(i&lt;b.length()) tmp+=(ans[i]-'0')+(b[i]-'0'); else tmp+=(ans[i]-'0'); ans[i]=tmp%10+'0'; tmp/=10; &#125; reverse(ans.begin(),ans.end()); return ans.substr(ans.find_first_not_of('0'));&#125;int main()&#123; string a="121323131213212131"; string b="435435435436566474324"; cout&lt;&lt;add(a,b)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用一条简单语句判断一个整数是否为2的整数次幂]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%80%E6%9D%A1%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82%2F</url>
    <content type="text"><![CDATA[在写代码的过程中可能会遇到判断一个整数是否为2的整数次幂的问题，除了枚举的方法，还可以利用二进制的知识进行简单快速判断。 2的整数次幂用二进制表示只存在一个1和n个0，因此，我们利用位运算&amp;判断一个整数a与a-1的&amp;是否为0即可。具体代码如下。 代码非常简洁。1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;bool judge(LL x)&#123; if((x&amp;(x-1))==0)return true;return false;&#125;int main()&#123;LL a;cin&gt;&gt;a;if(judge(a))cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
