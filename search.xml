<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[win7搭建深度学习视觉环境教程]]></title>
    <url>%2F2019%2F04%2F30%2Fwin7%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%A7%86%E8%A7%89%E7%8E%AF%E5%A2%83%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[DP之多维动态规划问题]]></title>
    <url>%2F2019%2F04%2F30%2FDP%E4%B9%8B%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解神经网络结构MobileNets]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84MobileNets%2F</url>
    <content type="text"><![CDATA[论文原文： https://arxiv.org/abs/1704.04861]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树之Kruskal]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BKruskal%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解dfs/bfs之寻路问题]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3dfs-bfs%E4%B9%8B%E5%AF%BB%E8%B7%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解辗转相除法以及线性方程解法]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[散列表的例子]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[数学等式 题目描述： 输入: a,b,c,d,e 输出: 满足等式成立的数据的组数 输入样例: -14 -42 -23 27 -48 输出样例: 3022 分析： &nbsp;&nbsp;一开始拿到题目可能会向费马定理或同余方程方面考虑，其实他给出了范围只需要进行枚举x散列就可以了。 &nbsp;&nbsp;代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define N 25000000#define sqr(X) (X*X*X)//宏定义#define rep(i,l,r) for(int i=l;i&lt;=r;++i)short s[25000001];int a,b,c,d,e,cnt=0;inline int rp(int x)&#123;//防止下标越界 if(x&lt;0) x+=N; return x;&#125;int main()&#123; for(;~scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);cnt=0)&#123;//输入数据 memset(s,0,sizeof s); rep(i,-50,50) if(i) rep(j,-50,50) if(j) s[rp(sqr(i)*d+sqr(j)*e)]++;//散列过程 rep(i,-50,50) if(i) rep(j,-50,50) if(j) rep(k,-50,50) if(k) cnt+=s[rp(sqr(i)*a+sqr(j)*b+sqr(k)*c)]; cout&lt;&lt;cnt&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无范围性枚举例子]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%97%A0%E8%8C%83%E5%9B%B4%E6%80%A7%E6%9E%9A%E4%B8%BE%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[p10011车站 题目描述: &nbsp;&nbsp;火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n−1站），都满足此规律。现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？ 输入输出格式输入格式：a(≤20)，n(≤20)，m(≤2000)，和x(≤20)， 输出格式：从x站开出时车上的人数。 输入样例： &nbsp;&nbsp;&nbsp;输入：5 7 32 4 &nbsp;&nbsp;&nbsp;输出：13 思路： &nbsp;&nbsp;这应该是一道类似斐波那契数列的数学问题，不同的是初始条件并没有给出，需要我们自己枚举判断是否初始条件符合要求，所以枚举的方法就应该是从0开始不断枚举先假设条件成立再反过来推此时的初始条件是否符合要求。代码如下：12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll up[30],down[30]; ll ans[30]; int a,n,m,x; cin&gt;&gt;a&gt;&gt;n&gt;&gt;m&gt;&gt;x; up[1]=a;//初始化 down[1]=0; ans[1]=a; ans[2]=a; for(int j=0;;j++)//枚举初始条件 &#123; up[2]=j; down[2]=j; for(int i=3;i&lt;n;i++) &#123; up[i]=up[i-1]+up[i-2];//模拟 down[i]=up[i-1]; ans[i]=ans[i-1]+up[i]-down[i]; &#125; ans[n]=0; if(ans[n-1]==m) &#123; cout&lt;&lt;ans[x]&lt;&lt;endl; break;//找到，退出 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己定义一个字符串类String]]></title>
    <url>%2F2019%2F04%2F23%2F%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBString%2F</url>
    <content type="text"><![CDATA[write a String class by c++自己定义一个字符串类String,使该类实现如下要求：String a=”Hello”;//重载=String b=a,c;//拷贝构造函数 c=b;//重载=String d=”world”; d+=a;重载+=b=a+d;//重载+bool f=a&gt;d;//重载+String e=a.toupper();//把字符串都变成大写String f=a.tolower();//把字符串都变成小写String m=”123”;int x=int(m);//把数字字符串强转成整型String str=” abc “;String str1=str.tmn();//去掉字符串中前缀后缀空格char x=str[1];str[0]=b; 这里用到了C++语言里面的重载，在比赛中经常会用到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;class String&#123; private: char *_str; public: String(char* str=NULL):_str(str)//初始化构造函数 &#123; if(str!=NULL) &#123; _str=new char[strlen(str)+1]; strcpy(_str,str); &#125; &#125; String(const String&amp;other):_str(other._str)//必须用拷贝构造函数 &#123; if(other._str!=NULL) &#123; _str=new char[strlen(other._str)+1]; strcpy(_str,other._str); &#125; &#125; String operator+(String other)//+重载&#123; int len=strlen(_str)+strlen(other._str); if(len==0) return String(); else &#123; char* buffer=new char [len+1]; strcpy(buffer,_str); strcat(buffer,other._str); String result(buffer); delete[]buffer; return result; &#125;&#125;bool operator!()//重载!&#123; if(_str==NULL||strlen(_str)==0) return true; else return false;&#125; operator int()//强转&#123; int num; num=atoi(_str); return num;&#125;String operator+=(String other)//重载+=&#123; int len=strlen(_str)+strlen(other._str); if(len==0) return *this; else &#123; char* buffer=new char[len+1]; strcpy(buffer,_str); strcat(buffer,other._str); delete[]_str; _str=buffer; return *this; &#125;&#125;char &amp;operator[](int index)//重载中括号&#123; return _str[index];&#125;bool operator&gt;(String other)&#123; return !strcmp(other._str,_str);&#125;friend ostream&amp; operator&lt;&lt;(ostream&amp;out,String &amp;d);//重载输出流String toupper()&#123; int l=strlen(_str); for(int i=0;i&lt;l;i++) &#123; if(_str[i]&gt;='a'&amp;&amp;_str[i]&lt;='z') _str[i]-=32; &#125; return _str;&#125;String tolower()&#123; int l=strlen(_str); for(int i=0;i&lt;l;i++) &#123; if(_str[i]&gt;='A'&amp;&amp;_str[i]&lt;='Z') _str[i]+=32; &#125; return _str;&#125;String tmn()&#123; char q[100]; int l=strlen(_str);//指向最后一位 int j=0; int i=0; int u=0; while(_str[i]==' ') &#123; i++;//指针移动 &#125; while(_str[l-1]==' ') l--; for(int k=i;k&lt;=l;k++) &#123; q[u++]=_str[k]; &#125; q[u]='\0'; return q;&#125;String&amp; operator=(const String &amp;other)//重载=&#123;if(other._str)&#123; delete _str; char*t=new char[strlen(other._str)+1]; strcpy(t,other._str); _str=t;&#125;else&#123; _str=0;&#125; return *this;&#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp;out,String &amp;d)&#123; out&lt;&lt;d._str; return out;&#125;int main()&#123;String m("123");String a="Hello";String b=a,c;c=b;String d="world";b=a+d;cout&lt;&lt;"a+d="&lt;&lt;b&lt;&lt;endl;d+=a;bool f=a&gt;b;cout&lt;&lt;"f="&lt;&lt;f&lt;&lt;endl;String str=" ee abc d";cout&lt;&lt;"去空格前:"&lt;&lt;str&lt;&lt;endl;String str1=str.tmn();String e=a.toupper();cout&lt;&lt;"e="&lt;&lt;e&lt;&lt;endl;String t=a.tolower();cout&lt;&lt;"t="&lt;&lt;t&lt;&lt;endl;char xx=str[1];cout&lt;&lt;"x=str[1]="&lt;&lt;xx&lt;&lt;endl;int x=int (m);cout&lt;&lt;"实数化m："&lt;&lt;x&lt;&lt;endl;cout&lt;&lt;"去空格后"&lt;&lt;str1&lt;&lt;endl;str[0]='b';return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindromic Supersequence]]></title>
    <url>%2F2019%2F04%2F23%2FPalindromic-Supersequence%2F</url>
    <content type="text"><![CDATA[Palindromic Supersequence time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given a string A. Find a string B, where B is a palindrome and A is a subsequence of B. A subsequence of a string is a string that can be derived from it by deleting some (not necessarily consecutive) characters without changing the order of the remaining characters. For example, “cotst” is a subsequence of “contest”. A palindrome is a string that reads the same forward or backward. The length of string B should be at most 104. It is guaranteed that there always exists such string. You do not need to find the shortest answer, the only restriction is that the length of string B should not exceed 104. Input First line contains a string A (1 ≤ |A| ≤ 103) consisting of lowercase Latin letters, where |A| is a length of A. Output Output single line containing B consisting of only lowercase Latin letters. You do not need to find the shortest answer, the only restriction is that the length of string B should not exceed 104. If there are many possible B, print any of them. Examples input abaoutput abainput aboutput aabaaNote In the first example, “aba” is a subsequence of “aba” which is a palindrome. In the second example, “ab” is a subsequence of “aabaa” which is a palindrome. 题意是给出一个字符串A，判断它是否回文，是的话输出，否则把它变成回文再输出。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int judge(string a)&#123; int l=a.length(); for(int i=0;i&lt;l;i++) &#123; if(a[i]==a[l-i-1]) &#123; &#125; else return 0; if(i==l/2+1) return 1; &#125; return 1;&#125;int main()&#123;string a;string b;string c;cin&gt;&gt;a;b.assign(a.rbegin(),a.rend());if(judge(a)) cout&lt;&lt;a&lt;&lt;endl;else&#123;c=a+b;if(c.length()&lt;10000)cout&lt;&lt;c&lt;&lt;endl;&#125;return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表基本操作]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define N 10typedef struct sl&#123; int s; struct sl *next;&#125;ss;ss *creat(int *s)&#123; int i=1; ss *p,*q,*h; h=p=(ss*)malloc(sizeof(ss)); p-&gt;s=s[0];while(i&lt;N)&#123; q=(ss*)malloc(sizeof(ss)); q-&gt;s=s[i]; i++; p-&gt;next=q; p=q;&#125;p-&gt;next=0;return h;&#125;int length(ss *phead)&#123; int n=0; ss *p=phead; while(p!=NULL) &#123; p=p-&gt;next; n++; &#125; return n;&#125;void output(ss *h)&#123; ss *p; p=h; if(h!=NULL); do &#123; printf("-&gt;%d",p-&gt;s); p=p-&gt;next; &#125;while(p!=0);printf("\n");&#125;void del(ss *h,int i)&#123; ss *p=h; ss *q; int j=0; while(p-&gt;next&amp;&amp;j&lt;(i-1)) &#123; p=p-&gt;next; ++j; &#125; q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q);&#125;ss *rev(ss *phead)&#123; ss *p1,*p2,*p3;if(phead==NULL||phead-&gt;next==NULL)return phead;p1=phead,p2=phead-&gt;next;while(p2)&#123;p3=p2-&gt;next;p2-&gt;next=p1;p1=p2;p2=p3;&#125;phead-&gt;next=NULL;phead=p1;return phead;&#125;main()&#123; int s[N]=&#123;1,2,3,4,5,6,7,8,9,10&#125;; ss *h; h=creat(s); output(h); h=rev(h); output(h);&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF Text Volume]]></title>
    <url>%2F2019%2F04%2F23%2FCF-Text-Volume%2F</url>
    <content type="text"><![CDATA[Text Volume 题目： You are given a text of single-space separated words, consisting of small and capital Latin letters. Volume of the word is number of capital letters in the word. Volume of the text is maximum volume of all words in the text. Calculate the volume of the given text. Input The first line contains one integer number n (1 ≤ n ≤ 200) — length of the text. The second line contains text of single-space separated words s1, s2, …, si, consisting only of small and capital Latin letters. Output Print one integer number — volume of text. input : 7NonZEROoutput: 5 input: 24Harbour Space Universityoutput: 1 题目分析： 给出一个用空格隔开的字符串，分别统计用空格隔开的每个单词大写字母的个数，并输出最大个数。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123;int j=0; int length;//字符串长度 string s;//输入字符串 int ss[201]=&#123;0&#125;;//保存每个单词大写字母个数 int sum=0;//统计大写字母个数 int bol=0;//判断字符串里书否有空格 cin&gt;&gt;length; cin.get();//输入带空格的字符串 getline(cin,s); for(int k=0;k&lt;length;k++) &#123; if(s[k]==' ') &#123; bol=1; &#125; &#125; if(bol==1) &#123; for(int i=0;i&lt;s.length();i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') sum++; if(s[i]==' ') &#123; ss[j++]=sum; sum=0; continue; &#125; &#125; ss[j++]=sum; &#125; else &#123; for(int p=0;p&lt;length;p++) &#123; if(s[p]&gt;='A'&amp;&amp;s[p]&lt;='Z') sum++; &#125; ss[0]=sum; &#125; sort(ss,ss+j,cmp); cout&lt;&lt;ss[0]&lt;&lt;endl;return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 939A Love Triangle]]></title>
    <url>%2F2019%2F04%2F23%2FCF-939A-Love-Triangle%2F</url>
    <content type="text"><![CDATA[A. Love Triangle As you could know there are no male planes nor female planes. However, each plane on Earth likes some other plane. There are n planes on Earth, numbered from 1 to n, and the plane with number i likes the plane with number fi, where 1 ≤ fi ≤ n and fi ≠ i. We call a love triangle a situation in which plane A likes plane B, plane B likes plane C and plane C likes plane A. Find out if there is any love triangle on Earth. Input The first line contains a single integer n (2 ≤ n ≤ 5000) — the number of planes. The second line contains n integers f1, f2, …, fn (1 ≤ fi ≤ n, fi ≠ i), meaning that the i-th plane likes the fi-th. Output Output «YES» if there is a love triangle consisting of planes on Earth. Otherwise, output «NO». You can output any letter in lower case or in upper case. Examples input Copy 52 4 5 1 3output YESinput Copy 55 5 5 5 1output NONote In first example plane 2 likes plane 4, plane 4 likes plane 1, plane 1 likes plane 2 and that is a love triangle. In second example there are no love triangles. 题目大意： 给出一个数组，找出里面是否有三个数满足以其中一个数为下标（从1开始）的数等于 另一个数且这另一个数等于那个数的下标。 代码：123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;int a[5001];using namespace std;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; if(a[a[a[i]]]==i) &#123; cout&lt;&lt;"YES"&lt;&lt;endl; return 0; &#125; &#125;cout&lt;&lt;"NO"&lt;&lt;endl;return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 938A WordCorrection]]></title>
    <url>%2F2019%2F04%2F23%2FCF-938A-WordCorrection%2F</url>
    <content type="text"><![CDATA[A. Word CorrectionVictor tries to write his own text editor, with word correction included. However, the rules of word correction are really strange. Victor thinks that if a word contains two consecutive vowels, then it’s kinda weird and it needs to be replaced. So the word corrector works in such a way: as long as there are two consecutive vowels in the word, it deletes the first vowel in a word such that there is another vowel right before it. If there are no two consecutive vowels in the word, it is considered to be correct. You are given a word s. Can you predict what will it become after correction? In this problem letters a, e, i, o, u and y are considered to be vowels. Input The first line contains one integer n (1 ≤ n ≤ 100) — the number of letters in word s before the correction. The second line contains a string s consisting of exactly n lowercase Latin letters — the word before the correction. Output Output the word s after the correction. Examples input Copy 5weirdoutput werdinput Copy 4wordoutput wordinput Copy 5aaeaaoutput aNote Explanations of the examples: There is only one replace: weird werd;No replace needed since there are no two consecutive vowels;aaeaa aeaa aaa aa a.题意： 给出一个字符串，不断去掉相邻的‘a,’e’,’i’,’o’,’u’,’y’中的右边那个，直到没有没有相邻的‘a,’e’,’i’,’o’,’u’,’y’。 代码：123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int bol;int main()&#123; int length; cin&gt;&gt;length; string s; cin&gt;&gt;s; while(1) &#123; bol=0; for(int i=0;i&lt;s.length();i++) &#123; if((s[i]=='a'||s[i]=='u'||s[i]=='y'||s[i]=='i'||s[i]=='o'||s[i]=='e')&amp;&amp;(s[i+1]=='a'||s[i+1]=='e'||s[i+1]=='y'||s[i+1]=='o'||s[i+1]=='u'||s[i+1]=='i')) &#123; s.erase(i+1,1); bol=1; &#125; &#125; if(bol==0) break; &#125; cout&lt;&lt;s; return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019美赛参加总结]]></title>
    <url>%2F2019%2F04%2F23%2F2019%E7%BE%8E%E8%B5%9B%E5%8F%82%E5%8A%A0%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[2019年美赛经验 &nbsp;&nbsp;记得在2018年光棍节的时候，我和两个学霸一起报了美赛，寒假的时候经过了4天的紧张的思考，还算比较正常地提交了论文（去年的时候差点没交上）最近出了结果是M也算是预料之中吧，不过没拿到特奖还是有点小遗憾的。。。 &nbsp;&nbsp;从大一以来参加的比赛也比较多了，唯一坚持下来的除了算法竞赛也就是数学建模了，指导老师是统计学专业的，所以通过建模我也对统计学方面产生了很大兴趣。6次不同级别的建模比赛和平时的积累也让我对以后的方向有了一个大致的了解。 &nbsp;&nbsp;今年我们选的是E题环境科学，Problem E: What is the Cost of Environmental Degradation? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要的题意是： 问题E：环境退化的代价是什么？&nbsp;&nbsp;经济理论往往忽视其决定对生物圈的影响，或假定其需要无限的资源或能力。这个观点有一个缺陷，环境现在正面临着后果。生物圈提供了许多自然过程来维持一个健康和可持续的人类生活环境，这被称为生态系统服务。例如将废物转化为食物、水过滤、种植食物、授粉植物以及将二氧化碳转化为氧气。然而，无论何时人类改变生态系统，我们都可能限制或删除生态系统服务。当地土地利用的小规模变化的影响，如修建一些道路、下水道、桥梁、房屋或工厂，似乎可以忽略不计。再加上这些小型项目，大型项目，如建设或迁移大型企业总部，在全国各地修建管道，或扩建或改造水道以扩大商业用途。现在想想这些项目对一个地区、国家和世界的影响。虽然这些活动似乎是个别的与生物圈功能潜力的总体能力无关，它们的累积直接影响生物多样性并导致环境退化。传统上，大多数土地利用项目不考虑生态系统服务的影响，也不考虑生态系统服务的变化。缓解土地利用变化带来的负面影响的经济成本：受污染的河流、空气质量差、有害废物场地、处理不良的废水、气候变化等，通常不包括在计划中。能否对土地利用开发项目的环境成本进行估价？如何在这些项目成本中考虑环境退化？一旦将生态系统服务纳入项目的成本效益比，就可以确定和评估项目的真实和全面的评估。 您的ICM团队被雇佣来创建一个生态服务评估模型，以便在考虑生态系统服务时了解土地使用项目的真实经济成本。使用您的模型对不同规模的土地利用开发项目（从小型社区项目到大型国家项目）进行成本效益分析。根据分析和模型设计评估模型的有效性。您的模型对土地利用项目规划人员和管理人员有什么影响？您的模型需要如何随时间变化？ &nbsp;&nbsp;&nbsp;&nbsp;其实拿到题目之后有经验的选手可以想到这是一个生态成本核算基本模型，可以有很多做法，最初想到的是利用arcgis的Invest生态评估模型来做，但由于软件使用不熟练，索性放弃，第二个思路是利用基本经济学模型来做，顺着这个思路我们确定了最终的方案。我们的大致思路是： 1、我们整理了中国南水北调东线起点泵站的一些成本核算模型和当地基本的环境数据建立指标体系。 2、我们利用主成分分析的结果得到了一个考虑到生态成本核算的成本核算模型，哪些因素应着重考虑。 3、我们建立了一种基于EVR(Eco-costs/Value Ratio)的动态规划成本评估模型，在保证不超过生态成本总预算的前提下，我们想尽可能地提高每种因子的生态效率，所以我们对每种生态影响因子是否纳入考核进行决策，并最终得到不超过成本预算下的最大生态效率。主要应用动态规划模型。 4、考虑到这个项目本身的调水行为会给项目所在区域生态系统产生巨大影响，需要巨大的生态恢复成本，然而政府补贴并不能满足治理需求，所以我们建立了一种可以保证水资源利用率的约束模型，想尽可能地提高受水地区的水资源利用效率，这样就可以尽可能减少水资源浪费率，使水源利用效益最大化。 5、对土地利用项目规划人员和管理人员，我们分析了我们的模型对项目具体实施过程中的影响并提出合理建议。 6、为了分析带有生态评估的成本核算模型。随时间的变化，我们先后建立了多项式回归模型和人工神经网络的生态评估因子预测模型进行了预测。 由于时间限制，论文的内容和排版我们已经尽力完美，也存在一些不足之处。最后附上一个通用的做题经验模板和我们的证书。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铺地毯]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%2F</url>
    <content type="text"><![CDATA[题目描述: 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出格式输入格式：输入共n+2行 第一行，一个整数n，表示总共有n张地毯 接下来的nn行中，第 i+1行表示编号ii的地毯的信息，包含四个正整数a ,b ,g ,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标(a,b)以及地毯在x轴和y轴方向的长度 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标(x,y)输出格式：输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 解答：简单进行一下模拟，不断更新最上面的地毯。12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct sq&#123; ll a; ll b; ll g; ll k;&#125;sq[10001];int main()&#123; ll n,x,y; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;sq[i].a&gt;&gt;sq[i].b&gt;&gt;sq[i].g&gt;&gt;sq[i].k; &#125; cin&gt;&gt;x&gt;&gt;y; int ans=-1; for(int i=0;i&lt;n;i++) &#123; if((x&gt;=sq[i].a)&amp;&amp;(x&lt;=(sq[i].a+sq[i].g))&amp;&amp;(y&gt;=sq[i].b)&amp;&amp;(y&lt;=sq[i].b+sq[i].k)) ans=i+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制奇偶位快速转换]]></title>
    <url>%2F2019%2F04%2F06%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E5%81%B6%E4%BD%8D%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[将整数二进制的奇偶位快速互换 有的题目需要将一个整数的二进制的奇偶位做互换，这时需要用到位运算的异或算符^。具体原理如下： 9的二进制1001，互换之后为0110。为了这个互换，我们需要将1001分别与上1010和0101记做ou（偶数位保留）和ji(奇数位保留)，将ou右移一位；将ji左移一位之后两者做异或运算即可。 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int m(int i)&#123;int ou=i&amp;0xaaaaaaaa;//这里0xaaaaaaaa作为1010 1010...取出偶数位共32位int ji=i&amp;0x55555555;//这里0x55555555作为0101 0101...取出奇数位共32位return (ou&gt;&gt;1)^(ji&lt;&lt;1);&#125;int main()&#123; int a=9; int b=m(a); cout&lt;&lt;b&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字转字符串itos]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%95%B0%E5%AD%97%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2itos%2F</url>
    <content type="text"><![CDATA[把一个数字转为字符串s 在输入的过程中经常需要将一个数字转化为字符串方便处理这里引入一个将数字转为字符串的函数i2s，主要利用c++的输入流。 代码：12345678910111213141516171819#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;using namespace std;void i2s(int num,string &amp;str)&#123; stringstream ss; ss&lt;&lt;num; ss&gt;&gt;str;&#125;int main()&#123; int i; cin&gt;&gt;i; string s; i2s(i,s); cout&lt;&lt;s&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度plus]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%AB%98%E7%B2%BE%E5%BA%A6plus%2F</url>
    <content type="text"><![CDATA[高精度大数的加法 众所周知，c++中最大整型的long long 一般表示8位，如果计算的数字超过这个范围的话会产生溢出的情况，这时需要用字符串人工来表述一个整数加法过程，所谓的高精度加法。 首先我们定义两个string类型的字符串作为我们输入的加数，（输入的时候可以利用itos函数将数字转为串）接着定义一个答案串长度为len，为了方便计算，我们先将字符串反转接着将第一个数存入答案串中，定义进位为tmp，然后用循环将另一个加数逐位加到答案串中，并计算进位情况。 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#include&lt;sstream&gt;using namespace std;string add(string a,string b)&#123; a=a.substr(a.find_first_not_of('0')); b=b.substr(b.find_first_not_of('0')); long long lenA=a.length(); long long lenB=b.length(); long long len=max(lenA,lenB)+10; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans(len,'0'); for(int i=0;i&lt;lenA;i++) &#123; ans[i]=a[i]; &#125; int tmp=0; for(int i=0;i&lt;len;i++) &#123; if(i&lt;b.length()) tmp+=(ans[i]-'0')+(b[i]-'0'); else tmp+=(ans[i]-'0'); ans[i]=tmp%10+'0'; tmp/=10; &#125; reverse(ans.begin(),ans.end()); return ans.substr(ans.find_first_not_of('0'));&#125;int main()&#123; string a="121323131213212131"; string b="435435435436566474324"; cout&lt;&lt;add(a,b)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用一条简单语句判断一个整数是否为2的整数次幂]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%80%E6%9D%A1%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82%2F</url>
    <content type="text"><![CDATA[在写代码的过程中可能会遇到判断一个整数是否为2的整数次幂的问题，除了枚举的方法，还可以利用二进制的知识进行简单快速判断。 2的整数次幂用二进制表示只存在一个1和n个0，因此，我们利用位运算&amp;判断一个整数a与a-1的&amp;是否为0即可。具体代码如下。 代码非常简洁。1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;bool judge(LL x)&#123; if((x&amp;(x-1))==0)return true;return false;&#125;int main()&#123;LL a;cin&gt;&gt;a;if(judge(a))cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
