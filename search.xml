<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019美赛参加总结]]></title>
    <url>%2F2019%2F04%2F23%2F2019%E7%BE%8E%E8%B5%9B%E5%8F%82%E5%8A%A0%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[2019年美赛经验 &nbsp;&nbsp;记得在2018年光棍节的时候，我和两个学霸一起报了美赛，寒假的时候经过了4天的紧张的思考，还算比较正常地提交了论文（去年的时候差点没交上）最近出了结果是M也算是预料之中吧，不过没拿到特奖还是有点小遗憾的（学霸说拿了特奖就在群里发100红包，差点就让他发了）。。。 &nbsp;&nbsp;从大一以来参加的比赛也比较多了，唯一坚持下来的除了算法竞赛也就是数学建模了，指导老师是统计学专业的，所以通过建模我也对统计学方面产生了很大兴趣。6次不同级别的建模比赛和平时的积累也让我对以后的方向有了一个大致的了解。 &nbsp;&nbsp;今年我们选的是E题环境科学，Problem E: What is the Cost of Environmental Degradation? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要的题意是： 问题E：环境退化的代价是什么？&nbsp;&nbsp;经济理论往往忽视其决定对生物圈的影响，或假定其需要无限的资源或能力。这个观点有一个缺陷，环境现在正面临着后果。生物圈提供了许多自然过程来维持一个健康和可持续的人类生活环境，这被称为生态系统服务。例如将废物转化为食物、水过滤、种植食物、授粉植物以及将二氧化碳转化为氧气。然而，无论何时人类改变生态系统，我们都可能限制或删除生态系统服务。当地土地利用的小规模变化的影响，如修建一些道路、下水道、桥梁、房屋或工厂，似乎可以忽略不计。再加上这些小型项目，大型项目，如建设或迁移大型企业总部，在全国各地修建管道，或扩建或改造水道以扩大商业用途。现在想想这些项目对一个地区、国家和世界的影响。虽然这些活动似乎是个别的与生物圈功能潜力的总体能力无关，它们的累积直接影响生物多样性并导致环境退化。传统上，大多数土地利用项目不考虑生态系统服务的影响，也不考虑生态系统服务的变化。缓解土地利用变化带来的负面影响的经济成本：受污染的河流、空气质量差、有害废物场地、处理不良的废水、气候变化等，通常不包括在计划中。能否对土地利用开发项目的环境成本进行估价？如何在这些项目成本中考虑环境退化？一旦将生态系统服务纳入项目的成本效益比，就可以确定和评估项目的真实和全面的评估。 您的ICM团队被雇佣来创建一个生态服务评估模型，以便在考虑生态系统服务时了解土地使用项目的真实经济成本。使用您的模型对不同规模的土地利用开发项目（从小型社区项目到大型国家项目）进行成本效益分析。根据分析和模型设计评估模型的有效性。您的模型对土地利用项目规划人员和管理人员有什么影响？您的模型需要如何随时间变化？ &nbsp;&nbsp;&nbsp;&nbsp;其实拿到题目之后有经验的选手可以想到这是一个生态成本核算基本模型，可以有很多做法，最初想到的是利用arcgis的Invest生态评估模型来做，但由于软件使用不熟练，索性放弃，第二个思路是利用基本经济学模型来做，顺着这个思路我们确定了最终的方案。我们的大致思路是： 1、我们整理了中国南水北调东线起点泵站的一些成本核算模型和当地基本的环境数据建立指标体系。 2、我们利用主成分分析的结果得到了一个考虑到生态成本核算的成本核算模型，哪些因素应着重考虑。 3、我们建立了一种基于EVR(Eco-costs/Value Ratio)的动态规划成本评估模型，在保证不超过生态成本总预算的前提下，我们想尽可能地提高每种因子的生态效率，所以我们对每种生态影响因子是否纳入考核进行决策，并最终得到不超过成本预算下的最大生态效率。主要应用动态规划模型。 4、考虑到这个项目本身的调水行为会给项目所在区域生态系统产生巨大影响，需要巨大的生态恢复成本，然而政府补贴并不能满足治理需求，所以我们建立了一种可以保证水资源利用率的约束模型，想尽可能地提高受水地区的水资源利用效率，这样就可以尽可能减少水资源浪费率，使水源利用效益最大化。 5、对土地利用项目规划人员和管理人员，我们分析了我们的模型对项目具体实施过程中的影响并提出合理建议。 6、为了分析带有生态评估的成本核算模型。随时间的变化，我们先后建立了多项式回归模型和人工神经网络的生态评估因子预测模型进行了预测。 由于时间限制，论文的内容和排版我们已经尽力完美了，也存在一些不足之处。最后附上一个通用的做题经验模板和我们的证书。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铺地毯]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%2F</url>
    <content type="text"><![CDATA[题目描述: 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出格式输入格式：输入共n+2行 第一行，一个整数n，表示总共有n张地毯 接下来的nn行中，第 i+1行表示编号ii的地毯的信息，包含四个正整数a ,b ,g ,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标(a,b)以及地毯在x轴和y轴方向的长度 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标(x,y)输出格式：输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 解答：简单进行一下模拟，不断更新最上面的地毯。12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct sq&#123; ll a; ll b; ll g; ll k;&#125;sq[10001];int main()&#123; ll n,x,y; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;sq[i].a&gt;&gt;sq[i].b&gt;&gt;sq[i].g&gt;&gt;sq[i].k; &#125; cin&gt;&gt;x&gt;&gt;y; int ans=-1; for(int i=0;i&lt;n;i++) &#123; if((x&gt;=sq[i].a)&amp;&amp;(x&lt;=(sq[i].a+sq[i].g))&amp;&amp;(y&gt;=sq[i].b)&amp;&amp;(y&lt;=sq[i].b+sq[i].k)) ans=i+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制奇偶位快速转换]]></title>
    <url>%2F2019%2F04%2F06%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E5%81%B6%E4%BD%8D%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[将整数二进制的奇偶位快速互换 有的题目需要将一个整数的二进制的奇偶位做互换，这时需要用到位运算的异或算符^。具体原理如下： 9的二进制1001，互换之后为0110。为了这个互换，我们需要将1001分别与上1010和0101记做ou（偶数位保留）和ji(奇数位保留)，将ou右移一位；将ji左移一位之后两者做异或运算即可。 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int m(int i)&#123;int ou=i&amp;0xaaaaaaaa;//这里0xaaaaaaaa作为1010 1010...取出偶数位共32位int ji=i&amp;0x55555555;//这里0x55555555作为0101 0101...取出奇数位共32位return (ou&gt;&gt;1)^(ji&lt;&lt;1);&#125;int main()&#123; int a=9; int b=m(a); cout&lt;&lt;b&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字转字符串itos]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%95%B0%E5%AD%97%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2itos%2F</url>
    <content type="text"><![CDATA[把一个数字转为字符串s 在输入的过程中经常需要将一个数字转化为字符串方便处理这里引入一个将数字转为字符串的函数i2s，主要利用c++的输入流。 代码：12345678910111213141516171819#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;using namespace std;void i2s(int num,string &amp;str)&#123; stringstream ss; ss&lt;&lt;num; ss&gt;&gt;str;&#125;int main()&#123; int i; cin&gt;&gt;i; string s; i2s(i,s); cout&lt;&lt;s&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度plus]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%AB%98%E7%B2%BE%E5%BA%A6plus%2F</url>
    <content type="text"><![CDATA[高精度大数的加法 众所周知，c++中最大整型的long long 一般表示8位，如果计算的数字超过这个范围的话会产生溢出的情况，这时需要用字符串人工来表述一个整数加法过程，所谓的高精度加法。 首先我们定义两个string类型的字符串作为我们输入的加数，（输入的时候可以利用itos函数将数字转为串）接着定义一个答案串长度为len，为了方便计算，我们先将字符串反转接着将第一个数存入答案串中，定义进位为tmp，然后用循环将另一个加数逐位加到答案串中，并计算进位情况。 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#include&lt;sstream&gt;using namespace std;string add(string a,string b)&#123; a=a.substr(a.find_first_not_of('0')); b=b.substr(b.find_first_not_of('0')); long long lenA=a.length(); long long lenB=b.length(); long long len=max(lenA,lenB)+10; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans(len,'0'); for(int i=0;i&lt;lenA;i++) &#123; ans[i]=a[i]; &#125; int tmp=0; for(int i=0;i&lt;len;i++) &#123; if(i&lt;b.length()) tmp+=(ans[i]-'0')+(b[i]-'0'); else tmp+=(ans[i]-'0'); ans[i]=tmp%10+'0'; tmp/=10; &#125; reverse(ans.begin(),ans.end()); return ans.substr(ans.find_first_not_of('0'));&#125;int main()&#123; string a="121323131213212131"; string b="435435435436566474324"; cout&lt;&lt;add(a,b)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用一条简单语句判断一个整数是否为2的整数次幂]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%80%E6%9D%A1%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82%2F</url>
    <content type="text"><![CDATA[在写代码的过程中可能会遇到判断一个整数是否为2的整数次幂的问题，除了枚举的方法，还可以利用二进制的知识进行简单快速判断。 2的整数次幂用二进制表示只存在一个1和n个0，因此，我们利用位运算&amp;判断一个整数a与a-1的&amp;是否为0即可。具体代码如下。 代码非常简洁。1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;bool judge(LL x)&#123; if((x&amp;(x-1))==0)return true;return false;&#125;int main()&#123;LL a;cin&gt;&gt;a;if(judge(a))cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
